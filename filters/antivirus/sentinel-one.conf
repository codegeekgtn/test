filter {

# SentinelOne filter version 2.0.1
# Support Syslog CEF format
# Based on https://docs.centrify.com/Content/IntegrationContent/SIEM/arcsight-cef/arcsight-cef-format.htm
# and https://docs.fortinet.com/document/fortisiem/6.1.0/external-systems-configuration-guide/298395/sentinelone

split {
  field => "message"
  terminator => "<utm-log-separator>"
}

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

if ![dataType] {
        #First, search to define the entry point contain CEF:, contain |something, or look for SentinelOne
        if [message] and ( ( ("CEF:" in [message] and [message] =~/\|(\w+)?(\s)?SentinelOne(\s)?(\w+)?\|/ ) or [message] =~/(\w+)?(\s)SentinelOne(\s)(\w+)?/ )
        and ( "rt=" in [message] or "uuid=" in [message] or "suser=" in [message] or "cat=" in [message] ) ) {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................# 
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "antivirus-sentinel-one" }
              }
#......................................................................#
#If CEF formatted log do the parsing of the message if not
#delete strings parts with conflictive format in the message, to move to key->value pairs format
        if ("CEF:" in [message] ) {
#......................................................................#
#Using grok to parse header of the message
            grok {
              match => {
                "message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?CEF:(\s)?%{INT:cef_version}%{GREEDYDATA:cef_msg_all}"
                ]
              }
            }
#......................................................................#
#Using grok to parse components of the cef_message_all
          if [cef_msg_all] {
            grok {
              match => {
                "cef_msg_all" => [
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:deviceVersion}\|%{DATA:signatureID}\|%{DATA:act_msg}\|%{DATA:severity}\|%{GREEDYDATA:cef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:signatureID}\|%{DATA:act_msg}\|%{DATA:severity}\|%{GREEDYDATA:cef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{GREEDYDATA:cef_msg}"
                ]
              }
            }
          }
        } else {
#Extract the relevant part of the message, to clean after
            grok {
              match => {
                "message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?SentinelOne(\s)%{WORD:irrelevant} %{WORD:irrelevant} %{GREEDYDATA:init_msg}"
                ]
              }
            }
            if [init_msg] {
               #If not CEF, log comes in [something@number something="xxxx"] format, we need only something="xxxx" to perform kv, so
               #First mutation replace ][something@number something= with something=, after this only the first occurrence of the format has to
               #be replaced
               mutate {
                 gsub => [
                   "init_msg", "\]\[(.+)@(\d+)(\s)\1=", " \1="
                 ]
               }
               #Second mutation delete the first occurence pending
               mutate {
                 gsub => [
                   "init_msg", "\[(.+)@(\d+)(\s)\1=", "\1="
                 ]
               }
               #Third mutation delete the last ] remaining
               grok {
                 match => {
                   "init_msg" => [
                      "%{GREEDYDATA:cef_msg}\]\s%{GREEDYDATA:end_msg}"
                   ]
                 }
               }
            }
        }
#......................................................................# 
#First, replace whitespaces with default string after = to avoid kv issues, example:
#gattServices= manufacturerName=MFN, generates -> gattServices="manufacturerName=MFN"
#and should generate two fields: gattServices and manufacturerName
    if [cef_msg] {
      mutate {
        gsub => [
          "cef_msg", "(\w+)= ", "\1=X0X "
        ]
      }
#......................................................................#
#Using the kv filter with default config, usefull in key-value logs

      kv { 
        source => "cef_msg" 
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
#......................................................................#
#Remove fields that have issues with kv filter (spaces or = in value)
   mutate {
      remove_field => ["[kv_field][rt]","[kv_field][destinationZoneURI]","[kv_field][msg]","[kv_field][customerURI]","[kv_field][destinationZoneExternalID]",
      "[kv_field][cs1]","[kv_field][cs2]","[kv_field][cs3]","[kv_field][cs4]","[kv_field][cs5]","[kv_field][cs6]","[kv_field][originalAgentZoneURI]","[kv_field][flexString1]","[kv_field][cat]",
      "[kv_field][cs1Label]","[kv_field][cs2Label]","[kv_field][cs3Label]","[kv_field][cs4Label]","[kv_field][cs5Label]","[kv_field][cs6Label]",
      "[kv_field][cn1]","[kv_field][cn2]","[kv_field][cn3]","[kv_field][cn4]","[kv_field][cn5]","[kv_field][cn6]","[kv_field][cn1Label]","[kv_field][cn2Label]","[kv_field][cn3Label]","[kv_field][cn4Label]","[kv_field][cn5Label]","[kv_field][cn6Label]",
      "[kv_field][suser]","[kv_field][ruleName]","[kv_field][duser]","[kv_field][accountName]","[kv_field][eventDesc]","[kv_field][endpointDeviceControlDeviceName]",
      "[kv_field][sourceAgentLastActivityTimestamp]","[kv_field][sourceAgentRegisterTimestamp]","[kv_field][manufacturerName]",
      "[kv_field][sourceUserName]","[kv_field][sourceGroupName]","[kv_field][siteName]",
      "[kv_field][deviceRuleType]"]
   }
#......................................................................#
#Using grok to parse kv issued fields
    if [cef_msg] {
          grok {
            match => {
              "cef_msg" => [
                 "rt=%{DATA:rt} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "destinationZoneURI=%{DATA:destinationZoneURI} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "msg=%{DATA:msg} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "customerURI=%{DATA:customerURI} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "destinationZoneExternalID=%{DATA:destinationZoneExternalID} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs1=%{DATA:cs1} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs2=%{DATA:cs2} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs3=%{DATA:cs3} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs4=%{DATA:cs4} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs5=%{DATA:cs5} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs6=%{DATA:cs6} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn1=%{DATA:cn1} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn2=%{DATA:cn2} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn3=%{DATA:cn3} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn4=%{DATA:cn4} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn5=%{DATA:cn5} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn6=%{DATA:cn6} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "originalAgentZoneURI=%{DATA:originalAgentZoneURI} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "flexString1=%{DATA:flexString1} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cat=%{DATA:cat} %{WORD}(\.%{WORD})?=","cat=%{GREEDYDATA:cat}"
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs1Label=%{DATA:cs1Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs2Label=%{DATA:cs2Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs3Label=%{DATA:cs3Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs4Label=%{DATA:cs4Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs5Label=%{DATA:cs5Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs6Label=%{DATA:cs6Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn1Label=%{DATA:cn1Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn2Label=%{DATA:cn2Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn3Label=%{DATA:cn3Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn4Label=%{DATA:cn4Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn5Label=%{DATA:cn5Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn6Label=%{DATA:cn6Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }
# New fields from real logs, version 1.0.2
# suser and duser are not new but now detected with spaces
          grok {
            match => {
              "cef_msg" => [
                 "suser=%{DATA:suser} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "duser=%{DATA:duser} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "ruleName=%{DATA:ruleName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "eventDesc=%{DATA:eventDesc} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "accountName=%{DATA:accountName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "endpointDeviceControlDeviceName=%{DATA:endpointDeviceControlDeviceName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceAgentLastActivityTimestamp=%{DATA:sourceAgentLastActivityTimestamp} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceAgentRegisterTimestamp=%{DATA:sourceAgentRegisterTimestamp} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "manufacturerName=%{DATA:manufacturerName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceUserName=%{DATA:sourceUserName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceGroupName=%{DATA:sourceGroupName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "siteName=%{DATA:siteName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "deviceRuleType=%{DATA:deviceRuleType} %{WORD}(\.%{WORD})?="
              ]
            }
          }
    }
#......................................................................#
#Add fields to the tree structure
#......................................................................#
        mutate {
          #Rename the filds out of kv results
          rename => { "[signatureID]" => "[kv_field][signatureID]" }
          rename => { "[embDeviceVendor]" => "[kv_field][embDeviceVendor]" }
          rename => { "[embDeviceProduct]" => "[kv_field][embDeviceProduct]" }
          rename => { "[act_msg]" => "[kv_field][act_msg]" }
          rename => { "[cef_version]" => "[kv_field][cef_version]" }
          rename => { "[deviceVersion]" => "[kv_field][deviceVersion]" }
          rename => { "[priority]" => "[kv_field][priority]" }
          rename => { "[severity]" => "[kv_field][severity]" }
          rename => { "[end_msg]" => "[kv_field][end_msg]" }
          
          #Rename fields with kv issues (individual groks)
          rename => { "[cs1]" => "[kv_field][cs1]" }
          rename => { "[cs2]" => "[kv_field][cs2]" }
          rename => { "[cs3]" => "[kv_field][cs3]" }
          rename => { "[cs4]" => "[kv_field][cs4]" }
          rename => { "[cs5]" => "[kv_field][cs5]" }
          rename => { "[cs6]" => "[kv_field][cs6]" }
          rename => { "[cs1Label]" => "[kv_field][cs1Label]" }
          rename => { "[cs2Label]" => "[kv_field][cs2Label]" }
          rename => { "[cs3Label]" => "[kv_field][cs3Label]" }
          rename => { "[cs4Label]" => "[kv_field][cs4Label]" }
          rename => { "[cs5Label]" => "[kv_field][cs5Label]" }
          rename => { "[cs6Label]" => "[kv_field][cs6Label]" }
          rename => { "[cn1]" => "[kv_field][cn1]" }
          rename => { "[cn2]" => "[kv_field][cn2]" }
          rename => { "[cn3]" => "[kv_field][cn3]" }
          rename => { "[cn4]" => "[kv_field][cn4]" }
          rename => { "[cn5]" => "[kv_field][cn5]" }
          rename => { "[cn6]" => "[kv_field][cn6]" }
          rename => { "[cn1Label]" => "[kv_field][cn1Label]" }
          rename => { "[cn2Label]" => "[kv_field][cn2Label]" }
          rename => { "[cn3Label]" => "[kv_field][cn3Label]" }
          rename => { "[cn4Label]" => "[kv_field][cn4Label]" }
          rename => { "[cn5Label]" => "[kv_field][cn5Label]" }
          rename => { "[cn6Label]" => "[kv_field][cn6Label]" }
          rename => { "[msg]" => "[kv_field][msg]" }
          rename => { "[customerURI]" => "[kv_field][customerURI]" }
          rename => { "[cat]" => "[kv_field][cat]" }
          rename => { "[rt]" => "[kv_field][rt]" }
          rename => { "[destinationZoneURI]" => "[kv_field][destinationZoneURI]" }
          rename => { "[destinationZoneExternalID]" => "[kv_field][destinationZoneExternalID]" }
          rename => { "[message]" => "[kv_field][message]" }
          rename => { "[duser]" => "[kv_field][duser]" }
          rename => { "[suser]" => "[kv_field][suser]" }
          rename => { "[originalAgentZoneURI]" => "[kv_field][originalAgentZoneURI]" }
          rename => { "[flexString1]" => "[kv_field][flexString1]" }
          rename => { "[ruleName]" => "[kv_field][ruleName]" }
          rename => { "[accountName]" => "[kv_field][accountName]" }
          rename => { "[eventDesc]" => "[kv_field][eventDesc]" }
          rename => { "[endpointDeviceControlDeviceName]" => "[kv_field][endpointDeviceControlDeviceName]" }
          rename => { "[sourceAgentLastActivityTimestamp]" => "[kv_field][sourceAgentLastActivityTimestamp]" }
          rename => { "[sourceAgentRegisterTimestamp]" => "[kv_field][sourceAgentRegisterTimestamp]" }
          rename => { "[manufacturerName]" => "[kv_field][manufacturerName]" }
          rename => { "[sourceUserName]" => "[kv_field][sourceUserName]" }
          rename => { "[sourceGroupName]" => "[kv_field][sourceGroupName]" }
          rename => { "[siteName]" => "[kv_field][siteName]" }
          rename => { "[deviceRuleType]" => "[kv_field][deviceRuleType]" }
        }

    #src can be in multiple fields
    if [kv_field][src] {
        mutate {
          rename => { "[kv_field][src]" => "[kv_field][src_ip]" }
        }
    } else if [kv_field][cs4Label] and ("clientIp" in [kv_field][cs4Label]) {
        mutate {
          rename => { "[kv_field][cs4]" => "[kv_field][src_ip]" }
        }
    } else if [kv_field][FromIPAddress] {
        mutate {
          rename => { "[kv_field][FromIPAddress]" => "[kv_field][src_ip]" }
        }
    }
#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {  
            ruby {
                code => '
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X") 
                            event.set("[logx][sentinel_one][#{k}]",nil)
                          elsif (k=~/^sourceIpAddresses\.((\d)+)$/)
                              event.set("[logx][sentinel_one][source_ip_base_list][#{k}]",v)
                              event.remove(k)
                          elsif (k=~/^sourceMacAddresses\.((\d)+)$/)
                              event.set("[logx][sentinel_one][source_mac_base_list][#{k}]",v)
                              event.remove(k)
                          elsif (k=~/^threatIndicatorsList\.((\d)+)$/)
                              event.set("[logx][sentinel_one][threat_ind_base_list][#{k}]",v)
                              event.remove(k)
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\'/, "")
                              event.set("[logx][sentinel_one][#{k}]",new_v)
                          else
                              event.set("[logx][sentinel_one][#{k}]",v)
                          end
                       end   
                    '
            }
          }
#......................................................................#
#Implement fields represented by a list of fields
#All source ip address in a string separated by comma
          if [source_ip_base_list] {
            ruby {
                code => '
                          field_verify=event.get("[logx][sentinel_one][source_ip_base_list]")
                          if field_verify
                            new_v=field_verify.to_hash.map{|k,v| "#{v}"}.join(", ")
                            event.set("[logx][sentinel_one][src_ip_list]",new_v)
                          end   
                    '
            }
          }
#All source mac address in a string separated by comma
          if [source_mac_base_list] {
            ruby {
                code => '
                          field_verify=event.get("[logx][sentinel_one][source_mac_base_list]")
                          if field_verify
                            new_v=field_verify.to_hash.map{|k,v| "#{v}"}.join(", ")
                            event.set("[logx][sentinel_one][src_mac_list]",new_v)
                          end  
                    '
            }
          }
#All threat indicators in a string separated by comma
          if [threat_ind_base_list] {
            ruby {
                code => '
                          field_verify=event.get("[logx][sentinel_one][threat_ind_base_list]")
                          if field_verify
                            new_v=field_verify.to_hash.map{|k,v| "#{v}"}.join(", ")
                            event.set("[logx][sentinel_one][threat_indicators_list]",new_v)
                          end  
                    '
            }
          }
#......................................................................#
#Renaming CEF formatted fields with multiple values inside, to match name of (multiple fields in one) in not CEF logs
   mutate {
          rename => { "[logx][sentinel_one][sourceMacAddresses]" => "[logx][sentinel_one][src_mac_list]" }
          rename => { "[logx][sentinel_one][threatIndicatorsList]" => "[logx][sentinel_one][threat_indicators_list]" }
          rename => { "[logx][sentinel_one][sourceIpAddresses]" => "[logx][sentinel_one][src_ip_list]" }
   }
#......................................................................#
   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version","kv_field",
      "not_defined","cef_msg_all","cef_msg","syslog_date_host","irrelevant","init_msg",
      "[logx][sentinel_one][threat_ind_base_list]","[logx][sentinel_one][source_mac_base_list]",
      "[logx][sentinel_one][source_ip_base_list]"]
   }
  }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
