filter {
  #https://docs.fortinet.com/document/fortiweb/7.2.2/log-message-reference/470577/introduction
  #Filter version 1.1.0

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

  if ![dataType] {
# The log destination is already identified by the agent so, don't need an entry point
#......................................................................#
  #First, replace whitespaces with default string after = to avoid kv issues, example:
  #device_id= date=2021-08-18, generates -> device_id="date=2021-08-18"
  #and should generate two fields: device_id and date
    mutate {
      gsub => [
        "message", "= ", "=X0X "
      ]
    }
    mutate {
      gsub => [
        "message", '=""', "=X0X "
      ]
    }

  #......................................................................#
  #Using grok to parse priority if present
    grok {
      match => {
        "message" => [
          "(<%{NUMBER:priority}>)?%{GREEDYDATA:message_rest}"
        ]
      }
    }

  #......................................................................#
  #Using the kv filter with default config, usefull in key-value logs
    if [message_rest] {
      kv { 
        source => "message_rest" 
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
  #......................................................................#
  #Remove fields that have issues with kv filter
    mutate {
      remove_field => ["[kv_field][msg]"]
    }
  #......................................................................#
  #Using grok to parse kv issued fields
    if [message_rest] {
      grok {
        match => {
          "message_rest" => [
            "%{GREEDYDATA} msg=%{QUOTEDSTRING:msg}%{GREEDYDATA}"
          ]
        }
      }
  #......................................................................#
  #Remove double quotation and add to kv_field
      mutate {
        gsub => ["[msg]", '"', ""]
      }
    }
    mutate {
      rename => { "msg" => "[kv_field][msg]" }
      rename => { "message" => "[kv_field][message]" }
    }
  #......................................................................#
  #Generating dataSource field required by CorrelationRulesEngine
    if (![dataSource]){
     mutate {
        add_field => { "dataSource" => "%{host}" }
     }
    }
  
  #......................................................................# 
  #Generating dataType field required by CorrelationRulesEngine
    mutate {
      add_field => {
        "dataType" => "firewall-fortiweb"
      }
    }
  #......................................................................#
  #Cleaning message field
    mutate {
        gsub => ["[kv_field][message]", "X0X", ""]
    }

  #......................................................................#
  #Set null the fields with de X0X value (default string for null), and replace simple and double quotation
  #also generate logx tree structure dynamically
    if [kv_field] {
      ruby {
        code => '
          event.get("[kv_field]").each do |k, v|
          if (v == "X0X") 
            event.set("[logx][fortiweb][#{k}]",nil)
          elsif !(v.kind_of?(Array))
            new_v = v.to_s.gsub(/\"/, "")
            new_v = new_v.gsub(/\'/, "")
            event.set("[logx][fortiweb][#{k}]",new_v)
          else
            event.set("[logx][fortiweb][#{k}]",v)
          end
          end   
        '
      }
    }
  #......................................................................#
  # Rename standard fields and fields out of kv result
    mutate { 
      rename => { "priority" => "[logx][fortiweb][priority]" }
      rename => { "[logx][fortiweb][srcip]" => "[logx][fortiweb][src_ip]" }
      rename => { "[logx][fortiweb][src]" => "[logx][fortiweb][src_ip]" }
      rename => { "[logx][fortiweb][srcport]" => "[logx][fortiweb][src_port]" }
      rename => { "[logx][fortiweb][dstip]" => "[logx][fortiweb][dest_ip]" }
      rename => { "[logx][fortiweb][dst]" => "[logx][fortiweb][dest_ip]" }
      rename => { "[logx][fortiweb][dstport]" => "[logx][fortiweb][dest_port]" }
      rename => { "[logx][fortiweb][dst_port]" => "[logx][fortiweb][dest_port]" }
    }

  #......................................................................#
  # Rename HTTP fields
    mutate { 
      rename => { "priority" => "[logx][fortiweb][priority]" }
      rename => { "[logx][fortiweb][HTTP_agent]" => "[logx][fortiweb][http_agent]" }
      rename => { "[logx][fortiweb][HTTP_response_time]" => "[logx][fortiweb][http_response_time]" }
      rename => { "[logx][fortiweb][HTTP_request_time]" => "[logx][fortiweb][http_request_time]" }
      rename => { "[logx][fortiweb][HTTP_request_bytes]" => "[logx][fortiweb][http_request_bytes]" }
      rename => { "[logx][fortiweb][HTTP_response_bytes]" => "[logx][fortiweb][http_response_bytes]" }
      rename => { "[logx][fortiweb][HTTP_retcode]" => "[logx][fortiweb][http_retcode]" }
      rename => { "[logx][fortiweb][HTTP_host]" => "[logx][fortiweb][http_host]" }
      rename => { "[logx][fortiweb][HTTP_method]" => "[logx][fortiweb][http_method]" }
      rename => { "[logx][fortiweb][HTTP_url]" => "[logx][fortiweb][http_url]" }
    }
  #......................................................................#	   
  #Formatting number values
    mutate {
        convert => {
          "[logx][fortiweb][priority]" => "integer"
          "[logx][fortiweb][duration]" => "integer"
          "[logx][fortiweb][sessionid]" => "integer"
          "[logx][fortiweb][transport]" => "integer"
          "[logx][fortiweb][src_port]" => "integer"
          "[logx][fortiweb][srcserver]" => "integer"
          "[logx][fortiweb][dest_port]" => "integer"
          "[logx][fortiweb][appid]" => "integer"
          "[logx][fortiweb][countapp]" => "integer"
          "[logx][fortiweb][rcvdbyte]" => "integer"
          "[logx][fortiweb][rcvdpkt]" => "integer"
          "[logx][fortiweb][rcvddelta]" => "integer"
          "[logx][fortiweb][sentbyte]" => "integer"
          "[logx][fortiweb][sentdelta]" => "integer"
          "[logx][fortiweb][sentpkt]" => "integer"
          "[logx][fortiweb][policyid]" => "integer"
          "[logx][fortiweb][eventtime]" => "integer"
          "[logx][fortiweb][countdns]" => "integer"
          "[logx][fortiweb][remport]" => "integer"
          "[logx][fortiweb][locport]" => "integer"
        }
    }

    
    #Generating action field for established connections
    #First for type traffic
    if [logx][fortiweb][type] and [logx][fortiweb][type] == "traffic" and [logx][fortiweb][status] and [logx][fortiweb][status] == "success"  {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    } 
    #Then for type event
    else if ([logx][fortiweb][type] and [logx][fortiweb][type] == "event" ) { 
      #Subtype system
      if ([logx][fortiweb][subtype] and [logx][fortiweb][action] and [logx][fortiweb][status]) 
      and ([logx][fortiweb][subtype] == "system" )
      and ( ([logx][fortiweb][action] == "login" and [logx][fortiweb][status] == "success") 
      or [logx][fortiweb][action] == "logout" ) {
        mutate {
          add_field => { "[logx][utm][action]" => "Success" }
        }  
      } 
    }

    #Finally, remove unnecessary fields
    mutate {
        remove_field => ["@version","path","message_rest","tags","kv_field","original_log_message","headers"]
    }
  }
}
