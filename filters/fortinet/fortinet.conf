filter {
 #Check the minimum fields present in fortinet log, based in docs and samples provided
 #Were 100 different fields identified in official docs, plus the identified in real logs, below 6 are used to identify fortinet log
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/357866/log-message-fields
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/656858/log-id-definitions
 #https://docs.fortinet.com/document/fortigate/7.2.2/fortios-log-message-reference/357866/log-message-fields (Update November 2022)
 #Filter version 2.0.1

 split {
   field => "message"
   terminator => "<utm-log-separator>"
 }

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

if [message] and ( "date=" in [message] and "time=" in [message] and "logid=" in [message]
 and "type=" in [message] and "subtype=" in [message] and "level=" in [message]) { 

#......................................................................# 
 #First, replace whitespaces with default string after = to avoid kv issues, example:
 #device_id= date=2021-08-18, generates -> device_id="date=2021-08-18"
 #and should generate two fields: device_id and date
      mutate {
        gsub => [
          "message", "= ", "=X0X "
        ]
      }

#......................................................................#
#Using grok to parse priority if present
        grok {
          match => {
            "message" => [
              "(<%{NUMBER:priority}>)?%{GREEDYDATA:message_rest}"
            ]
          }
        }

#......................................................................#
#Using the kv filter with default config, usefull in key-value logs
    if [message_rest] {
      kv { 
        source => "message_rest" 
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
#......................................................................#
#Remove fields that have issues with kv filter
   mutate {
      remove_field => ["[kv_field][msg]"]
   }
#......................................................................#
#Using grok to parse kv issued fields
    if [message_rest] {
          grok {
            match => {
              "message_rest" => [
                 "%{GREEDYDATA} msg=%{QUOTEDSTRING:msg}%{GREEDYDATA}"
              ]
            }
          }
#......................................................................#
#Remove double quotation and add to kv_field
          mutate {
            gsub => ["[msg]", '"', ""]
          }
    }
          mutate {
            rename => { "msg" => "[kv_field][msg]" }
            rename => { "message" => "[kv_field][message]" }
          }
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if devname field is present or if it has no value, in those
#cases datasource points to host field
 if ([kv_field][devname]){
      if !([kv_field][devname]=="X0X") {
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[kv_field][devname]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{[kv_field][devname]}" }
          }
        }
      }
 }
#Finally evaluates to the host variable if can not be calculated
 if ![dataSource] {
    mutate {
       add_field => { "dataSource" => "%{host}" }
     }
 }

#......................................................................# 
#Generating dataType field required by CurrelationRulesEngine
   mutate {
		  add_field => {
			"dataType" => "firewall-fortigate-traffic"
		  }
	   }
#......................................................................#
#Cleaning message field
   mutate {
      gsub => ["[kv_field][message]", "X0X", ""]
   }

#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {
            ruby {
                code => '
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X") 
                            event.set("[logx][fortigate][#{k}]",nil)
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\'/, "")
                              event.set("[logx][fortigate][#{k}]",new_v)
                          else
                              event.set("[logx][fortigate][#{k}]",v)
                          end
                       end   
                    '
            }
          }
#......................................................................#
#Rename standard fields and fields out of kv result
      mutate { 
        rename => { "priority" => "[logx][fortigate][priority]" }
        rename => { "[logx][fortigate][srcip]" => "[logx][fortigate][src_ip]" }
        rename => { "[logx][fortigate][srcport]" => "[logx][fortigate][src_port]" }
        rename => { "[logx][fortigate][dstip]" => "[logx][fortigate][dest_ip]" }
        rename => { "[logx][fortigate][dstport]" => "[logx][fortigate][dest_port]" }
      }
#......................................................................#	   
#Formatting number values
   mutate {
      convert => {
        "[logx][fortigate][priority]" => "integer"
        "[logx][fortigate][duration]" => "integer"
        "[logx][fortigate][sessionid]" => "integer"
        "[logx][fortigate][transport]" => "integer"
        "[logx][fortigate][src_port]" => "integer"
        "[logx][fortigate][srcserver]" => "integer"
        "[logx][fortigate][dest_port]" => "integer"
        "[logx][fortigate][appid]" => "integer"
        "[logx][fortigate][countapp]" => "integer"
        "[logx][fortigate][rcvdbyte]" => "integer"
        "[logx][fortigate][rcvdpkt]" => "integer"
        "[logx][fortigate][rcvddelta]" => "integer"
        "[logx][fortigate][sentbyte]" => "integer"
        "[logx][fortigate][sentdelta]" => "integer"
        "[logx][fortigate][sentpkt]" => "integer"
        "[logx][fortigate][policyid]" => "integer"
        "[logx][fortigate][eventtime]" => "integer"
        "[logx][fortigate][proto]" => "integer"
        "[logx][fortigate][countdns]" => "integer"
        "[logx][fortigate][remport]" => "integer"
        "[logx][fortigate][locport]" => "integer"
        }
   }

   
   #Generating action field for established connections
   #First for type traffic
   if ([logx][fortigate][type] and [logx][fortigate][action]) and ([logx][fortigate][type] == "traffic" and [logx][fortigate][action] != "deny") {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
   } 
   #Then for type event
   else if ([logx][fortigate][type] and [logx][fortigate][type] == "event" ) { 
       #Subtype system
       if ([logx][fortigate][subtype] and [logx][fortigate][action] and [logx][fortigate][status]) 
       and ([logx][fortigate][subtype] == "system" )
       and ( ([logx][fortigate][action] == "login" and [logx][fortigate][status] == "success") 
       or [logx][fortigate][action] == "logout" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }  
       } 
       #Subtype vpn
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "vpn" 
       and ([logx][fortigate][action] == "negotiate" or [logx][fortigate][action] == "ssl-new-con" 
       or [logx][fortigate][action] == "install_sa" or [logx][fortigate][action] == "tunnel-stats"
       or [logx][fortigate][action] == "tunnel-up" or [logx][fortigate][action] == "tunnel-down"
       or [logx][fortigate][action] == "phase2-up" or [logx][fortigate][action] == "phase2-down") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype user
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "user" 
       and (("-logon" in [logx][fortigate][action] or "-logoff" in [logx][fortigate][action] or "-logout" in [logx][fortigate][action] ) 
       or ("authentication" in [logx][fortigate][action] and ([logx][fortigate][status] and [logx][fortigate][status] == "success") ) ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype endpoint
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "endpoint" 
       and ( [logx][fortigate][action] == "add" or [logx][fortigate][action] == "close" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }
   #Then for types or subtypes related to utm
   else if [logx][fortigate][type] and [logx][fortigate][type] == "utm" {
       #Subtype webfilter
       if ([logx][fortigate][subtype] and [logx][fortigate][action]) 
       and ([logx][fortigate][subtype] == "webfilter" or [logx][fortigate][subtype] == "waf") 
       and ( [logx][fortigate][action] == "passthrough" or [logx][fortigate][action] == "allow" or [logx][fortigate][action] == "allowed" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }  
       }
       #Subtype dlp
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "dlp" 
       and [logx][fortigate][action] != "block" and [logx][fortigate][action] != "drop" and [logx][fortigate][action] != "dropped" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype VoIP
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "voip" 
       and [logx][fortigate][action] == "permit" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype Application
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "app-ctrl" 
       and [logx][fortigate][action] == "pass" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype ssh
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "ssh" 
       and [logx][fortigate][action] == "passthrough" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }
   #Then for type dns
   else if ([logx][fortigate][type] and [logx][fortigate][type] == "dns" ) { 
       #Subtype dns-response
       if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "dns-response" 
       and [logx][fortigate][action] == "pass" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
    }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","message_rest","tags","kv_field"]
   }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
